$date
	Fri Apr 18 01:43:13 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module alu_tb $end
$var wire 32 ! result [31:0] $end
$var reg 32 " a [31:0] $end
$var reg 3 # aluControl [2:0] $end
$var reg 32 $ b [31:0] $end
$scope module uut $end
$var wire 32 % a [31:0] $end
$var wire 3 & aluControl [2:0] $end
$var wire 32 ' b [31:0] $end
$var wire 32 ( zeroextenderoutput [31:0] $end
$var wire 1 ) zeroextenderinput $end
$var wire 32 * yXor [31:0] $end
$var wire 32 + yAnd [31:0] $end
$var wire 1 , xorResult2 $end
$var wire 1 - xorResult $end
$var wire 32 . sum [31:0] $end
$var wire 32 / result [31:0] $end
$var wire 1 0 overflow $end
$var wire 32 1 outMux2 [31:0] $end
$var wire 1 2 invxorResult $end
$var wire 1 3 invAluControl1 $end
$var wire 32 4 bInv [31:0] $end
$var wire 1 5 Cout $end
$scope module AND1 $end
$var wire 32 6 a [31:0] $end
$var wire 32 7 b [31:0] $end
$var wire 32 8 y [31:0] $end
$upscope $end
$scope module AND2 $end
$var wire 1 0 y $end
$var wire 1 3 c $end
$var wire 1 , b $end
$var wire 1 2 a $end
$upscope $end
$scope module INV_1_1 $end
$var wire 1 9 a $end
$var wire 1 3 y $end
$upscope $end
$scope module INV_1_2 $end
$var wire 1 2 y $end
$var wire 1 - a $end
$upscope $end
$scope module INV_32_1 $end
$var wire 32 : a [31:0] $end
$var wire 32 ; y [31:0] $end
$upscope $end
$scope module XOR1 $end
$var wire 32 < a [31:0] $end
$var wire 32 = b [31:0] $end
$var wire 32 > y [31:0] $end
$upscope $end
$scope module XOR2 $end
$var wire 1 ? a $end
$var wire 1 @ b $end
$var wire 1 A c $end
$var wire 1 - y $end
$upscope $end
$scope module XOR3 $end
$var wire 1 B a $end
$var wire 1 C b $end
$var wire 1 , y $end
$upscope $end
$scope module XOR4 $end
$var wire 1 0 a $end
$var wire 1 D b $end
$var wire 1 ) y $end
$upscope $end
$scope module adder $end
$var wire 1 E Cin $end
$var wire 32 F a [31:0] $end
$var wire 32 G sum [31:0] $end
$var wire 32 H b [31:0] $end
$var wire 1 5 Cout $end
$upscope $end
$scope module mux2 $end
$var wire 32 I in0 [31:0] $end
$var wire 32 J in1 [31:0] $end
$var wire 1 K sel $end
$var wire 32 L out [31:0] $end
$upscope $end
$scope module mux5 $end
$var wire 32 M in0 [31:0] $end
$var wire 32 N in1 [31:0] $end
$var wire 32 O in2 [31:0] $end
$var wire 32 P in3 [31:0] $end
$var wire 3 Q sel [2:0] $end
$var wire 32 R in4 [31:0] $end
$var reg 32 S out [31:0] $end
$upscope $end
$scope module ze $end
$var wire 1 ) a $end
$var wire 32 T y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 T
b1111 S
b0 R
b0 Q
b1111 P
b0 O
b1111 N
b1111 M
b101 L
0K
b11111111111111111111111111111010 J
b101 I
b101 H
b1111 G
b1010 F
0E
0D
0C
0B
0A
0@
0?
b1111 >
b101 =
b1010 <
b11111111111111111111111111111010 ;
b101 :
09
b0 8
b101 7
b1010 6
05
b11111111111111111111111111111010 4
13
12
b101 1
00
b1111 /
b1111 .
0-
0,
b0 +
b1111 *
0)
b0 (
b101 '
b0 &
b1010 %
b101 $
b0 #
b1010 "
b1111 !
$end
#10000
15
02
1-
1K
1E
1A
b1101 !
b1101 /
b1101 S
b11111111111111111111111111111000 4
b11111111111111111111111111111000 ;
b11111111111111111111111111111000 J
b11111111111111111111111111111000 1
b11111111111111111111111111111000 H
b11111111111111111111111111111000 L
b100 +
b100 8
b100 O
b10011 *
b10011 >
b10011 P
b1101 .
b1101 G
b1101 M
b1101 N
b1 #
b1 &
b1 Q
b111 $
b111 '
b111 7
b111 :
b111 =
b111 I
b10100 "
b10100 %
b10100 6
b10100 <
b10100 F
#20000
12
05
03
0-
b1010 1
b1010 H
b1010 L
0K
0E
19
0A
b1000 !
b1000 /
b1000 S
b11111111111111111111111111110101 4
b11111111111111111111111111110101 ;
b11111111111111111111111111110101 J
b1000 +
b1000 8
b1000 O
b11 *
b11 >
b11 P
b10011 .
b10011 G
b10011 M
b10011 N
b10 #
b10 &
b10 Q
b1010 $
b1010 '
b1010 7
b1010 :
b1010 =
b1010 I
b1001 "
b1001 %
b1001 6
b1001 <
b1001 F
#30000
b1 (
b1 R
b1 T
1)
1,
1D
1B
02
1-
1K
1E
1A
b10000 !
b10000 /
b10000 S
b11111111111111111111111111101110 4
b11111111111111111111111111101110 ;
b11111111111111111111111111101110 J
b11111111111111111111111111101110 1
b11111111111111111111111111101110 H
b11111111111111111111111111101110 L
b1 +
b1 8
b1 O
b10000 *
b10000 >
b10000 P
b11111111111111111111111111110000 .
b11111111111111111111111111110000 G
b11111111111111111111111111110000 M
b11111111111111111111111111110000 N
b11 #
b11 &
b11 Q
b10001 $
b10001 '
b10001 7
b10001 :
b10001 =
b10001 I
b1 "
b1 %
b1 6
b1 <
b1 F
#40000
13
b11111111111111111111111111110101 1
b11111111111111111111111111110101 H
b11111111111111111111111111110101 L
09
b1 !
b1 /
b1 S
b11111111111111111111111111110101 4
b11111111111111111111111111110101 ;
b11111111111111111111111111110101 J
b0 +
b0 8
b0 O
b1111 *
b1111 >
b1111 P
b11111111111111111111111111111011 .
b11111111111111111111111111111011 G
b11111111111111111111111111111011 M
b11111111111111111111111111111011 N
b101 #
b101 &
b101 Q
b1010 $
b1010 '
b1010 7
b1010 :
b1010 =
b1010 I
b101 "
b101 %
b101 6
b101 <
b101 F
#50000
